library GetOpt  // Simple command-line options parser
"Lists.fif" include

// May be used as follows:
// begin-options
//   "h" { ."Help Message" 0 halt } short-option
//   "v" { parse-int =: verbosity } short-option-arg
//   "i" "--interactive" { true =: interactive } short-long-option
// parse-options

// ( l -- l')  computes tail of list l if non-empty; else ()
{ dup null? ' cdr ifnot } : safe-cdr
// ( l c -- l')  deletes first c elements from list l
{ ' safe-cdr swap times } : list-delete-first
// ( l n c -- l' )  deletes c elements starting from n-th in list l
recursive list-delete-range {
  dup 0<= { 2drop } {
  over 0<= { nip list-delete-first } {
  swap 1- swap rot uncons 2swap list-delete-range cons
  } cond } cond
} swap !
// ( n c -- )  deletes $n .. $(n+c-1) from the argument list $*
{ swap 1- $* @ swap rot list-delete-range $* ! } : $*del.. 
// ( s s' -- ? )  checks whether s' is a prefix of s
{ tuck $len over $len over >= { $| drop $= } { 2drop drop false } cond
} : $pfx?
// ( s -- ? )  checks whether s is an option (a string beginning with '-')
{ dup $len 1 > { "-" $pfx? } { drop false } cond } : is-opt?
// ( l -- s i or 0 )  finds first string in l beginning with '-'
{ 0 { 1+ over null? { 2drop 0 true } {
  swap uncons over is-opt? { drop swap true } { nip swap false } cond
  } cond } until
} : list-find-opt
// ( -- s i or 0 )  finds first option in cmdline args
{ $* @ list-find-opt } : first-opt
// ( s t -- ? )  checks whether short/long option s matches description t
{ third $= } : short-option-matches
' second : get-opt-flags
' first : get-opt-exec
{ dup get-opt-flags 4 and 0= 3 + [] $=
} : long-option-matches
// ( s l -- t -1 or 0 )  finds short/long option s in list l
{ swap 1 { swap short-option-matches } does assoc-gen
} : lookup-short-option
{ swap 1 { swap long-option-matches } does assoc-gen
} : lookup-long-option
// ( s -- s' null or s' s'' )  Splits long option --opt=arg at '='
{ dup "=" $pos 1+ ?dup { tuck $| swap rot 1- $| drop swap } { null } cond
} : split-longopt
// ( l -- i or 0 ) 
// parses command line arguments according to option description list l
// and returns index i of first incorrect option
{ { first-opt dup 0= { true } {
    swap dup "--" $pfx? {  // l i s
      dup $len 2 = { drop dup 1 $*del.. 0 true } {
      split-longopt swap 3 pick
      lookup-long-option not { drop true } { // l i s' t f
      dup get-opt-exec swap get-opt-flags 3 and // l i s' e f'
      2 pick null? { dup 1 = } { dup 0= negate } cond  // l i s' e f' f''
      dup 1 = { 2drop 2drop true } {
      { drop nip over 1+ $() swap execute 2 $*del.. false } {
      ' nip ifnot execute 1 $*del.. false
    } cond } cond } cond } cond } { // l i s
      1 $| nip {
        dup $len 0= { drop 1 $*del.. false true } {
        1 $| swap 3 pick  // l i s' s l
        lookup-short-option not { drop true true } { // l i s' t
        dup get-opt-exec swap get-opt-flags 3 and  // l i s' e f'
        ?dup 0= { execute false } {
        2 pick $len { drop execute "" false } {
        2 = { nip null swap execute "" false } {  // l i e
        nip over 1+ $() swap execute 2 $*del.. false true
      } cond } cond } cond } cond } cond } until
    } cond
  } cond } until nip
} : getopt
// ( l -- )  Parses options and throws an error on failure
{ getopt ?dup { $() "cannot parse command line options near `" swap $+ +"`" abort } if
} : run-getopt

anon constant opt-list-marker
' opt-list-marker : begin-options
{ opt-list-marker list-until-marker } : end-options
{ end-options run-getopt } : parse-options
// ( s e -- o )  Creates short/long option s with execution token e
{ 0 rot triple } dup : short-option : long-option
// ( s s' e -- o ) Creates a combined short option s and long option s' with execution token e
{ 4 2swap 4 tuple } : short-long-option
{ 1 rot triple } dup : short-option-arg : long-option-arg
{ 2 rot triple } dup : short-option-?arg : long-option-?arg
{ 5 2swap 4 tuple } : short-long-option-arg
{ 6 2swap 4 tuple } : short-long-option-?arg
